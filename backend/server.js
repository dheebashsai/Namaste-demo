const express = require('express');const bodyParser = require('body-parser');const cors = require('cors');const fs = require('fs');const path = require('path');const jwt = require('jsonwebtoken');const { v4: uuidv4 } = require('uuid');const app = express();app.use(cors());app.use(bodyParser.json({limit:'5mb'}));const namasteData = JSON.parse(fs.readFileSync(path.join(__dirname,'namaste.sample.json')));const conceptMap = [];namasteData.forEach(item=>{ if(item.tm2Codes) item.tm2Codes.forEach(c=>conceptMap.push({source:item.code,targetSystem:'tm2',target:c})); if(item.biomedCodes) item.biomedCodes.forEach(c=>conceptMap.push({source:item.code,targetSystem:'biomed',target:c})); }); const JWT_SECRET='demo-secret-key'; app.post('/auth/login',(req,res)=>{ const {username}=req.body; const token=jwt.sign({username:username||'demo-user'},JWT_SECRET,{expiresIn:'12h'}); res.json({token}); }); app.get('/api/terminology/autocomplete',(req,res)=>{ const q=(req.query.q||'').toLowerCase(); if(!q) return res.json([]); const results=namasteData.filter(item=>item.display.toLowerCase().includes(q)||item.code.toLowerCase().includes(q)).slice(0,20).map(it=>({code:it.code,display:it.display,discipline:it.discipline})); res.json(results); }); app.post('/api/terminology/translate',(req,res)=>{ const {sourceCode}=req.body; if(!sourceCode) return res.status(400).json({error:'sourceCode required'}); const maps=conceptMap.filter(m=>m.source===sourceCode); res.json({source:sourceCode,mappings:maps}); }); function requireAuth(req,res,next){ const auth=req.headers['authorization']; if(!auth) return res.status(401).json({error:'Missing Authorization header (use /auth/login to get a demo token)'}); const parts=auth.split(' '); if(parts.length!==2) return res.status(401).json({error:'Invalid Authorization header'}); try{ const decoded=jwt.verify(parts[1],JWT_SECRET); req.user=decoded; next(); }catch(err){ return res.status(401).json({error:'Invalid token'}); } } app.post('/api/fhir/bundle',requireAuth,(req,res)=>{ const bundle=req.body; if(!bundle||!bundle.entry) return res.status(400).json({error:'Invalid FHIR Bundle'}); bundle.entry.forEach(entry=>{ const resource=entry.resource; if(resource&&resource.resourceType==='Condition'&&resource.code&&resource.code.coding){ const namasteCodings = resource.code.coding.filter(c=> c.system && (c.system.includes('namaste')|| c.system==='NAMASTE')); namasteCodings.forEach(nc=>{ const src=nc.code; const maps=conceptMap.filter(m=>m.source===src); maps.forEach(m=>{ if(!resource.code.coding.find(c=>c.code===m.target)){ resource.code.coding.push({ system: m.targetSystem==='tm2' ? 'http://who.int/icd11/tm2' : 'http://who.int/icd11/biomed', code: m.target, display: m.target }); } }); }); } }); const audit={id:uuidv4(), user:req.user.username, action:'BundleIngest', at:new Date().toISOString()}; const auditPath=path.join(__dirname,'audits.json'); let audits=[]; try{ audits=JSON.parse(fs.readFileSync(auditPath)); }catch(e){ audits=[]; } audits.push(audit); fs.writeFileSync(auditPath, JSON.stringify(audits,null,2)); res.json({message:'Bundle processed', bundle, audit}); }); app.get('/api/audit/logs',requireAuth,(req,res)=>{ const auditPath=path.join(__dirname,'audits.json'); let audits=[]; try{ audits=JSON.parse(fs.readFileSync(auditPath)); }catch(e){ audits=[]; } res.json(audits); }); app.get('/api/fhir/codesystem/namaste',(req,res)=>{ const cs={resourceType:'CodeSystem', url:'http://example.org/fhir/CodeSystem/namaste', concept: namasteData.map(it=>({code:it.code, display:it.display}))}; res.json(cs); }); const port=process.env.PORT||5000; app.listen(port,()=>console.log('Backend listening on',port));